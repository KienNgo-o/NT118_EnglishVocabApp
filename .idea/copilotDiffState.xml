<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/nt118_englishvocabapp/ui/flashcard/FlashcardViewModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/nt118_englishvocabapp/ui/flashcard/FlashcardViewModel.java" />
              <option name="originalContent" value="package com.example.nt118_englishvocabapp.ui.flashcard;&#10;&#10;import android.app.Application;&#10;import android.util.Log;&#10;import android.content.Context;&#10;import android.content.SharedPreferences;&#10;import android.util.Base64;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.lifecycle.AndroidViewModel;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.lifecycle.MutableLiveData;&#10;&#10;import com.example.nt118_englishvocabapp.models.Definition;&#10;import com.example.nt118_englishvocabapp.models.FlashcardItem;&#10;import com.example.nt118_englishvocabapp.models.LearnableItem;&#10;import com.example.nt118_englishvocabapp.models.Topic;&#10;import com.example.nt118_englishvocabapp.network.ApiService;&#10;import com.example.nt118_englishvocabapp.network.RetrofitClient;&#10;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;import retrofit2.Call;&#10;import retrofit2.Callback;&#10;import retrofit2.Response;&#10;&#10;public class FlashcardViewModel extends AndroidViewModel {&#10;&#10;    private final ApiService apiService;&#10;    private static final String TAG = &quot;FlashcardViewModel&quot;;&#10;&#10;    // LiveData cho Màn hình 1 (Danh sách chủ đề)&#10;    private final MutableLiveData&lt;List&lt;Topic&gt;&gt; topicList = new MutableLiveData&lt;&gt;();&#10;&#10;    // LiveData cho Màn hình 2 (Danh sách thẻ học &quot;LearnableItem&quot; đã làm phẳng)&#10;    private final MutableLiveData&lt;List&lt;LearnableItem&gt;&gt; learnableList = new MutableLiveData&lt;&gt;();&#10;&#10;    // LiveData cho thông báo lỗi&#10;    private final MutableLiveData&lt;String&gt; error = new MutableLiveData&lt;&gt;();&#10;    // Bộ nhớ đệm local đơn giản cho số lượng từ theo topic để hiển thị nhanh trong khi network refresh&#10;    private final SharedPreferences prefs;&#10;&#10;    // --- Mới: Lưu tiến trình học Flashcard ---&#10;    // Lưu tiến trình theo chủ đề vào SharedPreferences với key &quot;flashcard_progress_topic_{id}&quot; và giá trị:&#10;    // base64(topicName)|studied|total|timestamp&#10;    private final SharedPreferences progressPrefs;&#10;    private final MutableLiveData&lt;List&lt;ProgressItem&gt;&gt; progressList = new MutableLiveData&lt;&gt;();&#10;&#10;    public FlashcardViewModel(@NonNull Application application) {&#10;        super(application);&#10;        this.apiService = RetrofitClient.getApiService(application.getApplicationContext());&#10;        // Use the shared primary cache name to match VocabViewModel&#10;        this.prefs = application.getApplicationContext().getSharedPreferences(&quot;topic_count_cache&quot;, Context.MODE_PRIVATE);&#10;        this.progressPrefs = application.getApplicationContext().getSharedPreferences(&quot;flashcard_progress&quot;, Context.MODE_PRIVATE);&#10;&#10;        // Initialize progress LiveData from stored prefs&#10;        loadProgressFromPrefs();&#10;    }&#10;&#10;    public LiveData&lt;List&lt;Topic&gt;&gt; getTopics() { return topicList; }&#10;    public LiveData&lt;List&lt;LearnableItem&gt;&gt; getLearnableItems() { return learnableList; }&#10;    public LiveData&lt;String&gt; getError() { return error; }&#10;    public LiveData&lt;List&lt;ProgressItem&gt;&gt; getProgressList() { return progressList; }&#10;&#10;    // --- Methods to save/load progress ---&#10;    /**&#10;     * Lưu tiến trình cho một chủ đề vào local (SharedPreferences).&#10;     * topicName có thể chứa ký tự đặc biệt nên được mã hóa base64.&#10;     * studied và total là các bộ đếm số nguyên. timestamp là System.currentTimeMillis().&#10;     */&#10;    public void saveProgress(int topicId, @NonNull String topicName, int studied, int total) {&#10;        long ts = System.currentTimeMillis();&#10;        // Resolve final topic name if not provided&#10;        String finalName = topicName;&#10;        try {&#10;            if ((finalName == null || finalName.isEmpty()) &amp;&amp; topicList.getValue() != null) {&#10;                for (Topic t : topicList.getValue()) {&#10;                    if (t != null &amp;&amp; t.getTopicId() == topicId) {&#10;                        finalName = t.getTopicName() != null ? t.getTopicName() : &quot;&quot;;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception ignored) {}&#10;        if (finalName == null) finalName = &quot;&quot;;&#10;&#10;        // Check existing stored progress for this topic to keep the highest value&#10;        int existingStudied = -1;&#10;        int existingTotal = -1;&#10;        long existingTs = -1L;&#10;        try {&#10;            String existing = progressPrefs.getString(&quot;progress_topic_&quot; + topicId, null);&#10;            if (existing != null) {&#10;                String[] parts = existing.split(&quot;\\|&quot;, -1);&#10;                if (parts.length &gt;= 4) {&#10;                    try { existingStudied = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) {}&#10;                    try { existingTotal = Integer.parseInt(parts[2]); } catch (NumberFormatException ignored) {}&#10;                    try { existingTs = Long.parseLong(parts[3]); } catch (NumberFormatException ignored) {}&#10;                }&#10;            } else {&#10;                // also check in-memory LiveData list&#10;                ProgressItem pi = getProgressForTopic(topicId);&#10;                if (pi != null) {&#10;                    existingStudied = pi.studied;&#10;                    existingTotal = pi.total;&#10;                    existingTs = pi.timestamp;&#10;                }&#10;            }&#10;        } catch (Exception ignored) {}&#10;&#10;        float newFraction = (total &lt;= 0) ? 0f : (float) studied / (float) total;&#10;        float oldFraction = (existingTotal &lt;= 0) ? 0f : (float) existingStudied / (float) existingTotal;&#10;&#10;        // If existing progress is better or equal, skip update (keep highest)&#10;        if (existingStudied &gt;= 0) {&#10;            if (newFraction &lt; oldFraction) {&#10;                Log.d(TAG, &quot;saveProgress skipped (lower fraction): topicId=&quot; + topicId + &quot; new=&quot; + newFraction + &quot; old=&quot; + oldFraction);&#10;                return;&#10;            } else if (Math.abs(newFraction - oldFraction) &lt; 1e-6 &amp;&amp; studied &lt;= existingStudied) {&#10;                Log.d(TAG, &quot;saveProgress skipped (no improvement): topicId=&quot; + topicId + &quot; studied=&quot; + studied + &quot; existing=&quot; + existingStudied);&#10;                return;&#10;            }&#10;        }&#10;&#10;        String encodedName = Base64.encodeToString(finalName.getBytes(StandardCharsets.UTF_8), Base64.NO_WRAP);&#10;        String value = encodedName + &quot;|&quot; + studied + &quot;|&quot; + total + &quot;|&quot; + ts;&#10;        progressPrefs.edit().putString(&quot;progress_topic_&quot; + topicId, value).apply();&#10;&#10;        Log.d(TAG, &quot;saveProgress: topicId=&quot; + topicId + &quot; name=&quot; + finalName + &quot; studied=&quot; + studied + &quot; total=&quot; + total + &quot; ts=&quot; + ts);&#10;&#10;        // Update in-memory LiveData&#10;        List&lt;ProgressItem&gt; current = progressList.getValue();&#10;        if (current == null) current = new ArrayList&lt;&gt;();&#10;        boolean found = false;&#10;        for (int i = 0; i &lt; current.size(); i++) {&#10;            ProgressItem pi = current.get(i);&#10;            if (pi.topicId == topicId) {&#10;                current.set(i, new ProgressItem(topicId, finalName, studied, total, ts));&#10;                found = true;&#10;                break;&#10;            }&#10;        }&#10;        if (!found) current.add(new ProgressItem(topicId, finalName, studied, total, ts));&#10;        progressList.postValue(current);&#10;    }&#10;&#10;    public ProgressItem getProgressForTopic(int topicId) {&#10;        List&lt;ProgressItem&gt; current = progressList.getValue();&#10;        if (current == null) return null;&#10;        for (ProgressItem pi : current) if (pi.topicId == topicId) return pi;&#10;        return null;&#10;    }&#10;&#10;    private void loadProgressFromPrefs() {&#10;        List&lt;ProgressItem&gt; list = new ArrayList&lt;&gt;();&#10;        try {&#10;            for (String key : progressPrefs.getAll().keySet()) {&#10;                if (!key.startsWith(&quot;progress_topic_&quot;)) continue;&#10;                Object obj = progressPrefs.getAll().get(key);&#10;                if (!(obj instanceof String)) continue;&#10;                String s = (String) obj;&#10;                String[] parts = s.split(&quot;\\|&quot;, -1);&#10;                if (parts.length &lt; 4) continue;&#10;                String encodedName = parts[0];&#10;                String name = new String(Base64.decode(encodedName, Base64.NO_WRAP), StandardCharsets.UTF_8);&#10;                int studied = 0;&#10;                int total = 0;&#10;                long ts = 0L;&#10;                try { studied = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) {}&#10;                try { total = Integer.parseInt(parts[2]); } catch (NumberFormatException ignored) {}&#10;                try { ts = Long.parseLong(parts[3]); } catch (NumberFormatException ignored) {}&#10;                String idStr = key.substring(&quot;progress_topic_&quot;.length());&#10;                int id = -1;&#10;                try { id = Integer.parseInt(idStr); } catch (NumberFormatException ignored) {}&#10;                if (id &gt;= 0) list.add(new ProgressItem(id, name, studied, total, ts));&#10;            }&#10;        } catch (Exception e) {&#10;            Log.w(TAG, &quot;Failed to load progress from prefs&quot;, e);&#10;        }&#10;        Log.d(TAG, &quot;loadProgressFromPrefs: loaded &quot; + list.size() + &quot; items&quot;);&#10;        progressList.postValue(list);&#10;    }&#10;&#10;    // Inner class representing saved progress for a topic&#10;    public static class ProgressItem {&#10;        public final int topicId;&#10;        public final String topicName;&#10;        public final int studied;&#10;        public final int total;&#10;        public final long timestamp;&#10;&#10;        public ProgressItem(int topicId, String topicName, int studied, int total, long timestamp) {&#10;            this.topicId = topicId;&#10;            this.topicName = topicName;&#10;            this.studied = studied;&#10;            this.total = total;&#10;            this.timestamp = timestamp;&#10;        }&#10;&#10;        public float getProgressFraction() {&#10;            if (total &lt;= 0) return 0f;&#10;            return (float) studied / (float) total;&#10;        }&#10;&#10;        public int getProgressPercent() {&#10;            return Math.round(getProgressFraction() * 100f);&#10;        }&#10;    }&#10;&#10;    // --- Logic gọi API ---&#10;&#10;    /**&#10;     * Gọi API 1: Lấy tất cả chủ đề&#10;     */&#10;    public void fetchTopics() {&#10;        apiService.getAllTopics().enqueue(new Callback&lt;List&lt;Topic&gt;&gt;() {&#10;            @Override&#10;            public void onResponse(@NonNull Call&lt;List&lt;Topic&gt;&gt; call, @NonNull Response&lt;List&lt;Topic&gt;&gt; response) {&#10;                if (response.isSuccessful() &amp;&amp; response.body() != null) {&#10;                    List&lt;Topic&gt; topics = response.body();&#10;&#10;                    // Initialize wordCount to -1 (unknown) for each topic&#10;                    for (Topic t : topics) t.setWordCount(-1);&#10;&#10;                    // Apply cached counts immediately so UI can show numbers fast&#10;                    for (Topic t : topics) {&#10;                        int cached = getCachedCountForTopic(t.getTopicId());&#10;                        if (cached &gt;= 0) t.setWordCount(cached);&#10;                    }&#10;&#10;                    // Post the topics immediately so UI can render placeholders&#10;                    topicList.postValue(topics);&#10;&#10;                    // Now fetch flashcards for each topic concurrently to compute counts&#10;                    // and post the updated list only once when all counts are ready to avoid UI flicker.&#10;                    fetchCountsForTopicsConcurrently(topics);&#10;&#10;                } else {&#10;                    Log.e(TAG, &quot;fetchTopics error: &quot; + response.code());&#10;                    error.postValue(&quot;Failed to load topics. Code: &quot; + response.code());&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onFailure(@NonNull Call&lt;List&lt;Topic&gt;&gt; call, @NonNull Throwable t) {&#10;                Log.e(TAG, &quot;fetchTopics failure: &quot;, t);&#10;                error.postValue(&quot;Network error: &quot; + t.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    // Helper: để gọi API flashcards cho mỗi chủ đề song song và thu thập số lượng&#10;    private void fetchCountsForTopicsConcurrently(final List&lt;Topic&gt; topics) {&#10;        if (topics == null || topics.isEmpty()) {&#10;            topicList.postValue(topics);&#10;            return;&#10;        }&#10;&#10;        final int n = topics.size();&#10;        final AtomicInteger remaining = new AtomicInteger(n);&#10;        final int[] counts = new int[n];&#10;&#10;        for (int i = 0; i &lt; n; i++) counts[i] = -1; // unknown until fetched&#10;&#10;        for (int i = 0; i &lt; n; i++) {&#10;            final int idx = i;&#10;            final Topic topic = topics.get(idx);&#10;            apiService.getFlashcardsForTopic(topic.getTopicId()).enqueue(new Callback&lt;List&lt;FlashcardItem&gt;&gt;() {&#10;                @Override&#10;                public void onResponse(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Response&lt;List&lt;FlashcardItem&gt;&gt; response) {&#10;                    int count = 0;&#10;                    if (response.isSuccessful() &amp;&amp; response.body() != null) {&#10;                        List&lt;FlashcardItem&gt; items = response.body();&#10;                        // Count total definitions (each Definition -&gt; 1 LearnableItem)&#10;                        int total = 0;&#10;                        for (FlashcardItem fi : items) {&#10;                            if (fi.getDefinitions() != null &amp;&amp; !fi.getDefinitions().isEmpty()) {&#10;                                total += fi.getDefinitions().size();&#10;                            } else {&#10;                                total += 1;&#10;                            }&#10;                        }&#10;                        count = total;&#10;                    }&#10;&#10;                    counts[idx] = count;&#10;&#10;                    // Build updated list reflecting current known counts&#10;                    List&lt;Topic&gt; updatedList = new ArrayList&lt;&gt;(n);&#10;                    for (int j = 0; j &lt; n; j++) {&#10;                        int wc = counts[j] &gt;= 0 ? counts[j] : topics.get(j).getWordCount();&#10;                        updatedList.add(topics.get(j).copyWithWordCount(wc));&#10;                    }&#10;&#10;                    // Persist this single count&#10;                    saveCountForTopic(topic.getTopicId(), count);&#10;                    Log.d(TAG, &quot;Computed count for topicId=&quot; + topic.getTopicId() + &quot; -&gt; &quot; + count);&#10;                    // Debug: log snapshot of counts&#10;                    try {&#10;                        StringBuilder sb = new StringBuilder();&#10;                        for (Topic tt : updatedList) sb.append(tt.getTopicId()).append(&quot;=&quot;).append(tt.getWordCount()).append(&quot;,&quot;);&#10;                        Log.d(TAG, &quot;Posting updated topic list counts: &quot; + sb.toString());&#10;                    } catch (Exception ignored) {}&#10;                    topicList.postValue(updatedList);&#10;&#10;                    remaining.decrementAndGet();&#10;                }&#10;&#10;                @Override&#10;                public void onFailure(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Throwable t) {&#10;                    counts[idx] = 0;&#10;                    List&lt;Topic&gt; updatedList = new ArrayList&lt;&gt;(n);&#10;                    for (int j = 0; j &lt; n; j++) {&#10;                        int wc = counts[j] &gt;= 0 ? counts[j] : topics.get(j).getWordCount();&#10;                        updatedList.add(topics.get(j).copyWithWordCount(wc));&#10;                    }&#10;                    saveCountForTopic(topic.getTopicId(), 0);&#10;                    topicList.postValue(updatedList);&#10;                    remaining.decrementAndGet();&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gọi API 2: Lấy flashcards cho một chủ đề&#10;     * Sau đó làm phẳng dữ liệu thành List&lt;LearnableItem&gt;&#10;     */&#10;    public void fetchFlashcards(int topicId) {&#10;        apiService.getFlashcardsForTopic(topicId).enqueue(new Callback&lt;List&lt;FlashcardItem&gt;&gt;() {&#10;            @Override&#10;            public void onResponse(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Response&lt;List&lt;FlashcardItem&gt;&gt; response) {&#10;                if (response.isSuccessful() &amp;&amp; response.body() != null) {&#10;&#10;                    List&lt;FlashcardItem&gt; originalItems = response.body();&#10;                    List&lt;LearnableItem&gt; flatList = new ArrayList&lt;&gt;();&#10;&#10;                    // Làm phẳng danh sách: mỗi định nghĩa của 1 từ → 1 LearnableItem riêng&#10;                    for (FlashcardItem item : originalItems) {&#10;                        if (item.getDefinitions() != null &amp;&amp; !item.getDefinitions().isEmpty()) {&#10;                            for (Definition def : item.getDefinitions()) {&#10;                                flatList.add(new LearnableItem(item, def));&#10;                            }&#10;                        } else {&#10;                            // Nếu từ không có định nghĩa, vẫn thêm vào danh sách để tránh mất dữ liệu&#10;                            flatList.add(new LearnableItem(item, null));&#10;                        }&#10;                    }&#10;&#10;                    learnableList.postValue(flatList);&#10;&#10;                } else {&#10;                    Log.e(TAG, &quot;fetchFlashcards error: &quot; + response.code());&#10;                    error.postValue(&quot;Failed to load flashcards. Code: &quot; + response.code());&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onFailure(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Throwable t) {&#10;                Log.e(TAG, &quot;fetchFlashcards failure: &quot;, t);&#10;                error.postValue(&quot;Network error: &quot; + t.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    // Local cache helpers&#10;    private void saveCountForTopic(int topicId, int count) {&#10;        // Save to primary shared cache so Vocab and Flashcard share the same store&#10;        prefs.edit().putInt(&quot;topic_count_&quot; + topicId, count).apply();&#10;    }&#10;&#10;    private int getCachedCountForTopic(int topicId) {&#10;        // Try primary cache first&#10;        int primary = prefs.getInt(&quot;topic_count_&quot; + topicId, -1);&#10;        if (primary &gt;= 0) return primary;&#10;&#10;        // Fallback to legacy storages to preserve previously saved counts&#10;        SharedPreferences legacyVocab = getApplication().getApplicationContext().getSharedPreferences(&quot;vocab_prefs&quot;, Context.MODE_PRIVATE);&#10;        int v = legacyVocab.getInt(&quot;topic_count_&quot; + topicId, -1);&#10;        if (v &gt;= 0) return v;&#10;&#10;        SharedPreferences legacyFlash = getApplication().getApplicationContext().getSharedPreferences(&quot;flashcard_prefs&quot;, Context.MODE_PRIVATE);&#10;        int f = legacyFlash.getInt(&quot;topic_count_&quot; + topicId, -1);&#10;        return f &gt;= 0 ? f : -1;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.nt118_englishvocabapp.ui.flashcard;&#10;&#10;import android.app.Application;&#10;import android.util.Log;&#10;import android.content.Context;&#10;import android.content.SharedPreferences;&#10;import android.util.Base64;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.lifecycle.AndroidViewModel;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.lifecycle.MutableLiveData;&#10;&#10;import com.example.nt118_englishvocabapp.models.Definition;&#10;import com.example.nt118_englishvocabapp.models.FlashcardItem;&#10;import com.example.nt118_englishvocabapp.models.LearnableItem;&#10;import com.example.nt118_englishvocabapp.models.Topic;&#10;import com.example.nt118_englishvocabapp.network.ApiService;&#10;import com.example.nt118_englishvocabapp.network.RetrofitClient;&#10;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;import retrofit2.Call;&#10;import retrofit2.Callback;&#10;import retrofit2.Response;&#10;&#10;public class FlashcardViewModel extends AndroidViewModel {&#10;&#10;    private final ApiService apiService;&#10;    private static final String TAG = &quot;FlashcardViewModel&quot;;&#10;&#10;    // LiveData cho Màn hình 1 (Danh sách chủ đề)&#10;    private final MutableLiveData&lt;List&lt;Topic&gt;&gt; topicList = new MutableLiveData&lt;&gt;();&#10;&#10;    // LiveData cho Màn hình 2 (Danh sách thẻ học &quot;LearnableItem&quot; đã làm phẳng)&#10;    private final MutableLiveData&lt;List&lt;LearnableItem&gt;&gt; learnableList = new MutableLiveData&lt;&gt;();&#10;&#10;    // LiveData cho thông báo lỗi&#10;    private final MutableLiveData&lt;String&gt; error = new MutableLiveData&lt;&gt;();&#10;    // Bộ nhớ đệm local đơn giản cho số lượng từ theo topic để hiển thị nhanh trong khi network refresh&#10;    private final SharedPreferences prefs;&#10;&#10;    // --- Mới: Lưu tiến trình học Flashcard ---&#10;    // Lưu tiến trình theo chủ đề vào SharedPreferences với key &quot;flashcard_progress_topic_{id}&quot; và giá trị:&#10;    // base64(topicName)|studied|total|timestamp&#10;    private final SharedPreferences progressPrefs;&#10;    private final MutableLiveData&lt;List&lt;ProgressItem&gt;&gt; progressList = new MutableLiveData&lt;&gt;();&#10;&#10;    public FlashcardViewModel(@NonNull Application application) {&#10;        super(application);&#10;        this.apiService = RetrofitClient.getApiService(application.getApplicationContext());&#10;        // Use the shared primary cache name to match VocabViewModel&#10;        this.prefs = application.getApplicationContext().getSharedPreferences(&quot;topic_count_cache&quot;, Context.MODE_PRIVATE);&#10;        this.progressPrefs = application.getApplicationContext().getSharedPreferences(&quot;flashcard_progress&quot;, Context.MODE_PRIVATE);&#10;&#10;        // Initialize progress LiveData from stored prefs&#10;        loadProgressFromPrefs();&#10;    }&#10;&#10;    public LiveData&lt;List&lt;Topic&gt;&gt; getTopics() { return topicList; }&#10;    public LiveData&lt;List&lt;LearnableItem&gt;&gt; getLearnableItems() { return learnableList; }&#10;    public LiveData&lt;String&gt; getError() { return error; }&#10;    public LiveData&lt;List&lt;ProgressItem&gt;&gt; getProgressList() { return progressList; }&#10;&#10;    // --- Methods to save/load progress ---&#10;    /**&#10;     * Lưu tiến trình cho một chủ đề vào local (SharedPreferences).&#10;     * topicName có thể chứa ký tự đặc biệt nên được mã hóa base64.&#10;     * studied và total là các bộ đếm số nguyên. timestamp là System.currentTimeMillis().&#10;     */&#10;    public void saveProgress(int topicId, @NonNull String topicName, int studied, int total) {&#10;        long ts = System.currentTimeMillis();&#10;        // Resolve final topic name if not provided&#10;        String finalName = topicName;&#10;        try {&#10;            if ((finalName == null || finalName.isEmpty()) &amp;&amp; topicList.getValue() != null) {&#10;                for (Topic t : topicList.getValue()) {&#10;                    if (t != null &amp;&amp; t.getTopicId() == topicId) {&#10;                        finalName = t.getTopicName() != null ? t.getTopicName() : &quot;&quot;;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception ignored) {}&#10;        if (finalName == null) finalName = &quot;&quot;;&#10;&#10;        // Check existing stored progress for this topic to keep the highest value&#10;        int existingStudied = -1;&#10;        int existingTotal = -1;&#10;        long existingTs = -1L;&#10;        try {&#10;            String existing = progressPrefs.getString(&quot;progress_topic_&quot; + topicId, null);&#10;            if (existing != null) {&#10;                String[] parts = existing.split(&quot;\\|&quot;, -1);&#10;                if (parts.length &gt;= 4) {&#10;                    try { existingStudied = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) {}&#10;                    try { existingTotal = Integer.parseInt(parts[2]); } catch (NumberFormatException ignored) {}&#10;                    try { existingTs = Long.parseLong(parts[3]); } catch (NumberFormatException ignored) {}&#10;                }&#10;            } else {&#10;                // also check in-memory LiveData list&#10;                ProgressItem pi = getProgressForTopic(topicId);&#10;                if (pi != null) {&#10;                    existingStudied = pi.studied;&#10;                    existingTotal = pi.total;&#10;                    existingTs = pi.timestamp;&#10;                }&#10;            }&#10;        } catch (Exception ignored) {}&#10;&#10;        float newFraction = (total &lt;= 0) ? 0f : (float) studied / (float) total;&#10;        float oldFraction = (existingTotal &lt;= 0) ? 0f : (float) existingStudied / (float) existingTotal;&#10;&#10;        // If existing progress is better or equal, skip update (keep highest)&#10;        if (existingStudied &gt;= 0) {&#10;            if (newFraction &lt; oldFraction) {&#10;                Log.d(TAG, &quot;saveProgress skipped (lower fraction): topicId=&quot; + topicId + &quot; new=&quot; + newFraction + &quot; old=&quot; + oldFraction);&#10;                return;&#10;            } else if (Math.abs(newFraction - oldFraction) &lt; 1e-6 &amp;&amp; studied &lt;= existingStudied) {&#10;                Log.d(TAG, &quot;saveProgress skipped (no improvement): topicId=&quot; + topicId + &quot; studied=&quot; + studied + &quot; existing=&quot; + existingStudied);&#10;                return;&#10;            }&#10;        }&#10;&#10;        String encodedName = Base64.encodeToString(finalName.getBytes(StandardCharsets.UTF_8), Base64.NO_WRAP);&#10;        String value = encodedName + &quot;|&quot; + studied + &quot;|&quot; + total + &quot;|&quot; + ts;&#10;        progressPrefs.edit().putString(&quot;progress_topic_&quot; + topicId, value).apply();&#10;&#10;        Log.d(TAG, &quot;saveProgress: topicId=&quot; + topicId + &quot; name=&quot; + finalName + &quot; studied=&quot; + studied + &quot; total=&quot; + total + &quot; ts=&quot; + ts);&#10;&#10;        // Update in-memory LiveData&#10;        List&lt;ProgressItem&gt; current = progressList.getValue();&#10;        if (current == null) current = new ArrayList&lt;&gt;();&#10;        boolean found = false;&#10;        for (int i = 0; i &lt; current.size(); i++) {&#10;            ProgressItem pi = current.get(i);&#10;            if (pi.topicId == topicId) {&#10;                current.set(i, new ProgressItem(topicId, finalName, studied, total, ts));&#10;                found = true;&#10;                break;&#10;            }&#10;        }&#10;        if (!found) current.add(new ProgressItem(topicId, finalName, studied, total, ts));&#10;        progressList.postValue(current);&#10;    }&#10;&#10;    public ProgressItem getProgressForTopic(int topicId) {&#10;        List&lt;ProgressItem&gt; current = progressList.getValue();&#10;        if (current == null) return null;&#10;        for (ProgressItem pi : current) if (pi.topicId == topicId) return pi;&#10;        return null;&#10;    }&#10;&#10;    private void loadProgressFromPrefs() {&#10;        List&lt;ProgressItem&gt; list = new ArrayList&lt;&gt;();&#10;        try {&#10;            for (String key : progressPrefs.getAll().keySet()) {&#10;                if (!key.startsWith(&quot;progress_topic_&quot;)) continue;&#10;                Object obj = progressPrefs.getAll().get(key);&#10;                if (!(obj instanceof String)) continue;&#10;                String s = (String) obj;&#10;                String[] parts = s.split(&quot;\\|&quot;, -1);&#10;                if (parts.length &lt; 4) continue;&#10;                String encodedName = parts[0];&#10;                String name = new String(Base64.decode(encodedName, Base64.NO_WRAP), StandardCharsets.UTF_8);&#10;                int studied = 0;&#10;                int total = 0;&#10;                long ts = 0L;&#10;                try { studied = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) {}&#10;                try { total = Integer.parseInt(parts[2]); } catch (NumberFormatException ignored) {}&#10;                try { ts = Long.parseLong(parts[3]); } catch (NumberFormatException ignored) {}&#10;                String idStr = key.substring(&quot;progress_topic_&quot;.length());&#10;                int id = -1;&#10;                try { id = Integer.parseInt(idStr); } catch (NumberFormatException ignored) {}&#10;                if (id &gt;= 0) list.add(new ProgressItem(id, name, studied, total, ts));&#10;            }&#10;        } catch (Exception e) {&#10;            Log.w(TAG, &quot;Failed to load progress from prefs&quot;, e);&#10;        }&#10;        Log.d(TAG, &quot;loadProgressFromPrefs: loaded &quot; + list.size() + &quot; items&quot;);&#10;        progressList.postValue(list);&#10;    }&#10;&#10;    // Inner class representing saved progress for a topic&#10;    public static class ProgressItem {&#10;        public final int topicId;&#10;        public final String topicName;&#10;        public final int studied;&#10;        public final int total;&#10;        public final long timestamp;&#10;&#10;        public ProgressItem(int topicId, String topicName, int studied, int total, long timestamp) {&#10;            this.topicId = topicId;&#10;            this.topicName = topicName;&#10;            this.studied = studied;&#10;            this.total = total;&#10;            this.timestamp = timestamp;&#10;        }&#10;&#10;        public float getProgressFraction() {&#10;            if (total &lt;= 0) return 0f;&#10;            return (float) studied / (float) total;&#10;        }&#10;&#10;        public int getProgressPercent() {&#10;            return Math.round(getProgressFraction() * 100f);&#10;        }&#10;    }&#10;&#10;    // --- Logic gọi API ---&#10;&#10;    /**&#10;     * Gọi API 1: Lấy tất cả chủ đề&#10;     */&#10;    public void fetchTopics() {&#10;        apiService.getAllTopics().enqueue(new Callback&lt;List&lt;Topic&gt;&gt;() {&#10;            @Override&#10;            public void onResponse(@NonNull Call&lt;List&lt;Topic&gt;&gt; call, @NonNull Response&lt;List&lt;Topic&gt;&gt; response) {&#10;                if (response.isSuccessful() &amp;&amp; response.body() != null) {&#10;                    List&lt;Topic&gt; topics = response.body();&#10;&#10;                    // Initialize wordCount to -1 (unknown) for each topic&#10;                    for (Topic t : topics) t.setWordCount(-1);&#10;&#10;                    // Apply cached counts immediately so UI can show numbers fast&#10;                    for (Topic t : topics) {&#10;                        int cached = getCachedCountForTopic(t.getTopicId());&#10;                        if (cached &gt;= 0) t.setWordCount(cached);&#10;                    }&#10;&#10;                    // Post the topics immediately so UI can render placeholders&#10;                    topicList.postValue(topics);&#10;&#10;                    // Now fetch flashcards for each topic concurrently to compute counts&#10;                    // and post the updated list only once when all counts are ready to avoid UI flicker.&#10;                    fetchCountsForTopicsConcurrently(topics);&#10;&#10;                } else {&#10;                    Log.e(TAG, &quot;fetchTopics error: &quot; + response.code());&#10;                    error.postValue(&quot;Failed to load topics. Code: &quot; + response.code());&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onFailure(@NonNull Call&lt;List&lt;Topic&gt;&gt; call, @NonNull Throwable t) {&#10;                Log.e(TAG, &quot;fetchTopics failure: &quot;, t);&#10;                error.postValue(&quot;Network error: &quot; + t.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    // Helper: để gọi API flashcards cho mỗi chủ đề song song và thu thập số lượng&#10;    private void fetchCountsForTopicsConcurrently(final List&lt;Topic&gt; topics) {&#10;        if (topics == null || topics.isEmpty()) {&#10;            topicList.postValue(topics);&#10;            return;&#10;        }&#10;&#10;        final int n = topics.size();&#10;        final AtomicInteger remaining = new AtomicInteger(n);&#10;        final int[] counts = new int[n];&#10;&#10;        for (int i = 0; i &lt; n; i++) counts[i] = -1; // unknown until fetched&#10;&#10;        for (int i = 0; i &lt; n; i++) {&#10;            final int idx = i;&#10;            final Topic topic = topics.get(idx);&#10;            apiService.getFlashcardsForTopic(topic.getTopicId()).enqueue(new Callback&lt;List&lt;FlashcardItem&gt;&gt;() {&#10;                @Override&#10;                public void onResponse(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Response&lt;List&lt;FlashcardItem&gt;&gt; response) {&#10;                    int count = 0;&#10;                    if (response.isSuccessful() &amp;&amp; response.body() != null) {&#10;                        List&lt;FlashcardItem&gt; items = response.body();&#10;                        // Count total definitions (each Definition -&gt; 1 LearnableItem)&#10;                        int total = 0;&#10;                        for (FlashcardItem fi : items) {&#10;                            if (fi.getDefinitions() != null &amp;&amp; !fi.getDefinitions().isEmpty()) {&#10;                                total += fi.getDefinitions().size();&#10;                            } else {&#10;                                total += 1;&#10;                            }&#10;                        }&#10;                        count = total;&#10;                    }&#10;&#10;                    counts[idx] = count;&#10;&#10;                    // Build updated list reflecting current known counts&#10;                    List&lt;Topic&gt; updatedList = new ArrayList&lt;&gt;(n);&#10;                    for (int j = 0; j &lt; n; j++) {&#10;                        int wc = counts[j] &gt;= 0 ? counts[j] : topics.get(j).getWordCount();&#10;                        updatedList.add(topics.get(j).copyWithWordCount(wc));&#10;                    }&#10;&#10;                    // Persist this single count&#10;                    saveCountForTopic(topic.getTopicId(), count);&#10;                    Log.d(TAG, &quot;Computed count for topicId=&quot; + topic.getTopicId() + &quot; -&gt; &quot; + count);&#10;                    // Debug: log snapshot of counts&#10;                    try {&#10;                        StringBuilder sb = new StringBuilder();&#10;                        for (Topic tt : updatedList) sb.append(tt.getTopicId()).append(&quot;=&quot;).append(tt.getWordCount()).append(&quot;,&quot;);&#10;                        Log.d(TAG, &quot;Posting updated topic list counts: &quot; + sb.toString());&#10;                    } catch (Exception ignored) {}&#10;                    topicList.postValue(updatedList);&#10;&#10;                    remaining.decrementAndGet();&#10;                }&#10;&#10;                @Override&#10;                public void onFailure(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Throwable t) {&#10;                    counts[idx] = 0;&#10;                    List&lt;Topic&gt; updatedList = new ArrayList&lt;&gt;(n);&#10;                    for (int j = 0; j &lt; n; j++) {&#10;                        int wc = counts[j] &gt;= 0 ? counts[j] : topics.get(j).getWordCount();&#10;                        updatedList.add(topics.get(j).copyWithWordCount(wc));&#10;                    }&#10;                    saveCountForTopic(topic.getTopicId(), 0);&#10;                    topicList.postValue(updatedList);&#10;                    remaining.decrementAndGet();&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gọi API 2: Lấy flashcards cho một chủ đề&#10;     * Sau đó làm phẳng dữ liệu thành List&lt;LearnableItem&gt;&#10;     */&#10;    public void fetchFlashcards(int topicId) {&#10;        apiService.getFlashcardsForTopic(topicId).enqueue(new Callback&lt;List&lt;FlashcardItem&gt;&gt;() {&#10;            @Override&#10;            public void onResponse(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Response&lt;List&lt;FlashcardItem&gt;&gt; response) {&#10;                if (response.isSuccessful() &amp;&amp; response.body() != null) {&#10;&#10;                    List&lt;FlashcardItem&gt; originalItems = response.body();&#10;                    List&lt;LearnableItem&gt; flatList = new ArrayList&lt;&gt;();&#10;&#10;                    // Làm phẳng danh sách: mỗi định nghĩa của 1 từ → 1 LearnableItem riêng&#10;                    for (FlashcardItem item : originalItems) {&#10;                        if (item.getDefinitions() != null &amp;&amp; !item.getDefinitions().isEmpty()) {&#10;                            for (Definition def : item.getDefinitions()) {&#10;                                flatList.add(new LearnableItem(item, def));&#10;                            }&#10;                        } else {&#10;                            // Nếu từ không có định nghĩa, vẫn thêm vào danh sách để tránh mất dữ liệu&#10;                            flatList.add(new LearnableItem(item, null));&#10;                        }&#10;                    }&#10;&#10;                    learnableList.postValue(flatList);&#10;&#10;                } else {&#10;                    Log.e(TAG, &quot;fetchFlashcards error: &quot; + response.code());&#10;                    error.postValue(&quot;Failed to load flashcards. Code: &quot; + response.code());&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onFailure(@NonNull Call&lt;List&lt;FlashcardItem&gt;&gt; call, @NonNull Throwable t) {&#10;                Log.e(TAG, &quot;fetchFlashcards failure: &quot;, t);&#10;                error.postValue(&quot;Network error: &quot; + t.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    // Local cache helpers&#10;    private void saveCountForTopic(int topicId, int count) {&#10;        // Save to primary shared cache so Vocab and Flashcard share the same store&#10;        prefs.edit().putInt(&quot;topic_count_&quot; + topicId, count).apply();&#10;    }&#10;&#10;    private int getCachedCountForTopic(int topicId) {&#10;        // Try primary cache first&#10;        int primary = prefs.getInt(&quot;topic_count_&quot; + topicId, -1);&#10;        if (primary &gt;= 0) return primary;&#10;&#10;        // Fallback to legacy storages to preserve previously saved counts&#10;        SharedPreferences legacyVocab = getApplication().getApplicationContext().getSharedPreferences(&quot;vocab_prefs&quot;, Context.MODE_PRIVATE);&#10;        int v = legacyVocab.getInt(&quot;topic_count_&quot; + topicId, -1);&#10;        if (v &gt;= 0) return v;&#10;&#10;        SharedPreferences legacyFlash = getApplication().getApplicationContext().getSharedPreferences(&quot;flashcard_prefs&quot;, Context.MODE_PRIVATE);&#10;        int f = legacyFlash.getInt(&quot;topic_count_&quot; + topicId, -1);&#10;        return f &gt;= 0 ? f : -1;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>